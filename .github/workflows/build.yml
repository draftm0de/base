name: BaseImage Builder

on:
  workflow_dispatch:
    inputs:
      stage:
        description: 'Choose build stage to run'
        required: true
        type: choice
        options:
          - '---choose---'
          - 'CADDY'

jobs:
  precondition:
    name: Check Required Files
    runs-on: ubuntu-latest
    outputs:
      files_exist: ${{ steps.check_files.outputs.files_exist }}
    steps:
      - name: checkout repository
        uses: actions/checkout@v4

      - name: Check for .env and docker-compose.yml
        id: check_files
        run: |
          files=(.env docker-compose.yml)
          
          for file in "${files[@]}"; do
            if [ ! -f "$file" ]; then
              echo "$file does not exist"
              file_exists=false
              break
            fi
          done
          
          if [ "$file_exists" = false ]; then
            echo "files_exist=false" >> $GITHUB_ENV
            echo "::set-output name=files_exist::false"
            exit 1
          else
            echo "files_exist=true" >> $GITHUB_ENV
            echo "::set-output name=files_exist::true"
          fi

  check-tag:
    name: verify image tag
    runs-on: ubuntu-latest
    needs: precondition
    if: needs.precondition.outputs.files_exist == 'true'
    steps:
      - name: checkout repository
        uses: actions/checkout@v4

      - name: log in to docker hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Approve give tag does not exist
        run: |
          # Ensource .env
          set -o allexport
          source .env
          set +o allexport
          
          # Dynamically set IMAGE_NAME and IMAGE_TAG based on input stage
          STAGE="${{ github.event.inputs.stage }}"
          IMAGE_NAME_VAR="${STAGE}_IMAGE_NAME"
          IMAGE_TAG_VAR="${STAGE}_IMAGE_TAG"
          
          IMAGE_NAME="${!IMAGE_NAME_VAR}"
          IMAGE_TAG="${!IMAGE_TAG_VAR}"
          
          TAG_EXISTS=$(curl -s -o /dev/null -w "%{http_code}" https://hub.docker.com/v2/repositories/${DOCKER_NAMESPACE}/${IMAGE_NAME}/tags/${IMAGE_TAG})
          if [ "$TAG_EXISTS" -eq "200" ]; then
            echo "TAG ${IMAGE_TAG} for IMAGE ${IMAGE_NAME} already exists"
            exit 1
          else
            echo "TAG ${IMAGE_TAG} for IMAGE ${IMAGE_NAME} does not exist"
          fi

  build_and_push:
    name: build and push to registry
    runs-on: ubuntu-latest
    needs: check-tag
    steps:
      - name: Checkout Source
        uses: actions/checkout@v4

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: build image and push
        run: |
          # Ensource .env
          set -o allexport
          source .env
          set +o allexport
          
          # Dynamically set IMAGE_NAME and IMAGE_TAG based on input stage
          STAGE="${{ github.event.inputs.stage }}"
          STAGE_LOWER=$(echo "$STAGE" | tr '[:upper:]' '[:lower:]')
          IMAGE_NAME_VAR="${STAGE}_IMAGE_NAME"
          IMAGE_TAG_VAR="${STAGE}_IMAGE_TAG"
          
          IMAGE_NAME="${!IMAGE_NAME_VAR}"
          IMAGE_NAME_LOWER=$(echo "$IMAGE_NAME" | tr '[:upper:]' '[:lower:]')
          
          IMAGE_TAG="${!IMAGE_TAG_VAR}"
          
          echo "Building Docker image..."
          docker compose -f docker-compose.yml build --no-cache --force-rm ${STAGE_LOWER}
          
          echo "Logging into Docker Hub..."
          docker login -u ${{ secrets.DOCKERHUB_USERNAME }} -p ${{ secrets.DOCKERHUB_TOKEN }}
          
          echo "Tagging Docker image..."
          docker tag ${STAGE_LOWER} ${DOCKER_NAMESPACE}/${IMAGE_NAME_LOWER}:${IMAGE_TAG}
          docker tag ${STAGE_LOWER} ${DOCKER_NAMESPACE}/${IMAGE_NAME_LOWER}:latest
          
          echo "Pushing Docker image to Docker Hub..."
          docker push ${DOCKER_NAMESPACE}/${IMAGE_NAME_LOWER}:${IMAGE_TAG}
          docker push ${DOCKER_NAMESPACE}/${IMAGE_NAME_LOWER}:latest
